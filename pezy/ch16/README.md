# Chapter 16. Templates and Generic Programming

## Exercise 16.1

> Define instantiation.

Class or function generated by the compiler from a template.

## Exercise 16.2

> Write and test your own versions of the `compare` functions.

[compare](ex16_02_compare.h)

## Exercise 16.3

> Call your `compare` function on two `Sales_data` objects to see how your compiler handles errors during instantiation.

```sh
error C2678: binary '<': no operator found which takes a left-hand operand of type 'const Sales_data' (or there is no acceptable conversion)
```

## Exercise 16.4

> Write a template that acts like the library `find` algorithm. The function will need two template type parameters, one to represent the function’s iterator parameters and the other for the type of the value. Use your function to find a given value in a `vector<int>` and in a `list<string>`.

[Find](ex16_04_find.h)

## Exercise 16.5

> Write a template version of the `print` function from 6.2.4 (p. 217) that takes a reference to an array and can handle arrays of any size and any element type.

[print](ex16_05_print_array.h)

## Exercise 16.6

> How do you think the library `begin` and `end` functions that take an array argument work? Define your own versions of these functions.

[begin and end](ex16_06_begin_end.h)

## Exercise 16.7

> Write a `constexpr` template that returns the size of a given array.

[SizeOfArray](ex16_07_sizeof_array.h)

## Exercise 16.8

> In the “Key Concept” box on page 108, we noted that as a matter of habit C++ programmers prefer using != to using <. Explain the rationale for this habit.

As we’ve seen, only a few library types, `vector` and `string` being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the `==` and `!=` operators. Most of those iterators do not have the `<` operator. By routinely using iterators and `!=`, we don’t have to worry about the precise type of container we’re processing.

## Exercise 16.9

> What is a function template? What is a class template?

- function template: Definition from which specific functions can be instantiated.
- class template: Definition from which specific classes can be instantiated.
- differ: the compiler cannot deduce the template parameter type(s) like function templates for a class template. we should supply the list of template arguments to use in place of the template parameters inside angle brackets following the template's name.

## Exercise 16.10

> What happens when a class template is instantiated?

the compiler **rewrites** the class template, **replacing each instance** of the template parameter `T` by the given template argument.

## Exercise 16.11

> The following definition of `List` is incorrect. How would you fix it?
>
> ```cpp
> template <typename elemType> class ListItem;
> template <typename elemType> class List {
> public:
>   List<elemType>();
>   List<elemType>(const List<elemType> &);
>   List<elemType>& operator=(const List<elemType> &);
>   ~List();
>   void insert(ListItem *ptr, elemType value);
> private:
>   ListItem *front, *end;
> };
> ```

use of class template `ListItem` requires template arguments.

```cpp
void insert(ListItem<elemType> *ptr, elemType value);
ListItem<elemType> *front, *end;
```

## Exercise 16.12

> Write your own version of the `Blob` and `BlobPtr` templates. including the various `const` members that were not shown in the text.

[`Blob`, `BlobPtr` and `ConstBlobPtr`](ex16_12_blob.h) | [Test](ex16_12_blob_test.cpp)

## Exercise 16.13

> Explain which kind of friendship you chose for the equality and relational operators for `BlobPtr`.

General friendship that each instantiation of `BlobPtr` grants access to the version of the equality and relational operators instantiated with the same type.

## Exercise 16.14

> Write a `Screen` class template that uses nontype parameters to define the height and width of the `Screen`.

[Screen](ex16_14_screen.h) | [Test](ex16_14_screen_test.cpp)

## Exercise 16.15

> Implement input and output operators for your `Screen` template. Which, if any, friends are necessary in class `Screen` to make the input and output operators work? Explain why each friend declaration, if any, was needed.

[Screen](ex16_14_screen.h) | [Test](ex16_14_screen_test.cpp)

same reason with `Blob`.

## Exercise 16.16

> Rewrite the `StrVec` class (§ 13.5, p. 526) as a template named `Vec`.

[Vec](ex16_16_vec.h) | [Test](ex16_16_vec_test.cpp)

## Exercise 16.17

> What, if any, are the differences between a type parameter that is declared as a `typename` and one that is declared as a `class`? When must `typename` be used?

When we want to inform the compiler that a name represents a type, we must use the keyword `typename`, not `class`.

## Exercise 16.18

> Explain each of the following function template declarations and identify whether any are illegal. Correct each error that you find.
>
> ```cpp
> (a) template <typename T, U, typename V> void f1(T, U, V);
> (b) template <typename T> T f2(int &T);
> (c) inline template <typename T> T foo(T, unsigned int*);
> (d) template <typename T> f4(T, T);
> (e) typedef char Ctype;
> template <typename Ctype> Ctype f5(Ctype a);
> ```

Fixed:

```cpp
(a) template <typename T, typename U, typename V> void f1(T, U, V);
(b) template <typename T> T f2(int &);
(c)
```

## Exercise 16.19

> Write a function that takes a reference to a container and prints the elements in that container. Use the container’s `size_type` and `size` members to control the loop that prints the elements.

## Exercise 16.20

> Rewrite the function from the previous exercise to use iterators returned from `begin` and `end` to control the loop.
